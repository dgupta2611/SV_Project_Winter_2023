package definitions;

//-----------------------------------------------------------------
// Key Params
//-----------------------------------------------------------------

	// Special Purpose Address Bits
	parameter AUTO_PRECHARGE_BIT     = 10;
	parameter ALL_BANKS_BIT          = 10;

	// Widths	
	parameter SDRAM_ADDR_W           = 24;
	parameter SDRAM_DATA_W           = 16;
 	parameter SDRAM_BANK_W           = 2;
 	parameter SDRAM_COL_W            = 9;
 	parameter SDRAM_ROW_W            = SDRAM_ADDR_W - SDRAM_COL_W - SDRAM_BANK_W; // 15
 	parameter SDRAM_DQM_W            = 2;
 	
	parameter SDRAM_BANKS            = 2 ** SDRAM_BANK_W;	

	// SDRAM timing
	parameter SDRAM_MHZ              = 50;
	parameter CYCLE_TIME_NS          = 1000 / SDRAM_MHZ;
	parameter SDRAM_READ_LATENCY     = 2;	
	parameter SDRAM_TRCD_CYCLES 	 = (20 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
	parameter SDRAM_TRP_CYCLES  	 = (20 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
	parameter SDRAM_TRFC_CYCLES 	 = (60 + (CYCLE_TIME_NS-1)) / CYCLE_TIME_NS;
	parameter SDRAM_START_DELAY      = 100000 / (1000 / SDRAM_MHZ);                // 5000 := 100uS
	parameter SDRAM_REFRESH_CYCLES   = ((64000*SDRAM_MHZ) / (2 ** SDRAM_ROW_W))-1;

	class data_rand #(parameter DAT_WID = 16);
		
		randc bit [DAT_WID-1:0] data;

		constraint dat_contr_upper_half { data[DAT_WID-1:DAT_WID/2] > 0; data[DAT_WID-1:DAT_WID/2] < 16; }
		constraint dat_contr_lower_half { data[DAT_WID/2-1:0] > 0; data[DAT_WID/2-1:0] < 16; }	
		
	endclass 

	class ref_mem;
		logic [31:0] M     [logic [22:0]];
		logic [3:0]  Mask  [logic [22:0]];

		function void write(logic [22:0] addr, logic [31:0] data, logic [3:0] wrMask);
			M[addr]    = data;
			Mask[addr] = wrMask;
		endfunction

		function logic [35:0] read(logic [22:0] addr);
			read = {Mask[addr], M[addr]};
		endfunction

	endclass 
endpackage